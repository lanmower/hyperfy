<!DOCTYPE html>
<html>
<head>
  <title>Rendering Diagnostic</title>
  <style>
    body {
      font-family: monospace;
      background: #1a1a1a;
      color: #00ff00;
      padding: 20px;
      margin: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-y: auto;
      height: 100vh;
    }
    .status { color: #ffff00; margin: 10px 0; }
    .success { color: #00ff00; }
    .error { color: #ff0000; }
    .info { color: #00aaff; }
    hr { border-color: #333; }
  </style>
</head>
<body>
<div id="output"></div>
<script>
const output = document.getElementById('output');
function log(msg, type = 'info') {
  const div = document.createElement('div');
  div.textContent = msg;
  div.className = type;
  output.appendChild(div);
  console.log(msg);
}

function hr() {
  const h = document.createElement('hr');
  output.appendChild(h);
}

log('=== HYPERFY RENDERING DIAGNOSTIC ===', 'status');

setTimeout(() => {
  log('\n[1] Checking PlayCanvas...');

  if (!window.pc) {
    log('ERROR: window.pc not found', 'error');
    return;
  }
  log('PlayCanvas available: ' + !!window.pc, 'success');

  const app = window.pc?.app;
  if (!app) {
    log('ERROR: window.pc.app not found', 'error');
    return;
  }
  log('App instance found: ' + !!app, 'success');
  log('App running: ' + app.isRunning, app.isRunning ? 'success' : 'error');

  hr();
  log('[2] Scene Structure...');
  log('Root entity: ' + app.root?.name, 'info');
  log('Root children: ' + app.root?.children?.length, 'info');

  if (app.root?.children?.length > 0) {
    log('\nRoot children breakdown:', 'status');
    app.root.children.forEach((child, i) => {
      const type = child.model ? 'mesh' : (child.camera ? 'camera' : 'entity');
      const meshes = child.model?.meshInstances?.length || 0;
      log(`  [${i}] ${child.name || 'unnamed'} (${type})${meshes ? ` - ${meshes} meshes` : ''}`, 'info');
    });
  } else {
    log('WARNING: No root children found', 'error');
  }

  hr();
  log('[3] Camera Status...');
  const activeCamera = app.scene?.activeCameraEntity;
  log('Active camera: ' + activeCamera?.name, activeCamera ? 'success' : 'error');
  if (activeCamera) {
    const pos = activeCamera.getLocalPosition();
    log(`Camera position: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)})`, 'info');
  }

  hr();
  log('[4] Mesh Instances...');
  const meshInstances = app.scene?.getMeshInstances?.() || [];
  log('Total mesh instances: ' + meshInstances.length, meshInstances.length > 0 ? 'success' : 'error');

  if (meshInstances.length > 0) {
    log('\nFirst 5 meshes:', 'status');
    meshInstances.slice(0, 5).forEach((mesh, i) => {
      const nodeName = mesh.node?.name || mesh.node?.meshInstance?.name || 'unknown';
      log(`  [${i}] ${nodeName}`, 'info');
    });
  }

  hr();
  log('[5] Canvas Status...');
  const canvas = document.querySelector('canvas');
  log('Canvas element: ' + (!!canvas ? 'found' : 'not found'), canvas ? 'success' : 'error');
  if (canvas) {
    log(`Canvas resolution: ${canvas.width} x ${canvas.height}`, 'info');
    log(`Canvas CSS size: ${canvas.offsetWidth} x ${canvas.offsetHeight}`, 'info');
    const rect = canvas.getBoundingClientRect();
    const visible = rect.width > 0 && rect.height > 0;
    log(`Canvas visible on screen: ${visible}`, visible ? 'success' : 'error');
  }

  hr();
  log('[6] VERDICT', 'status');

  const appRunning = app?.isRunning;
  const cameraActive = !!activeCamera;
  const meshesVisible = meshInstances.length > 0;

  if (!appRunning) {
    log('FAIL: App not running', 'error');
  } else if (!cameraActive) {
    log('FAIL: Camera not active', 'error');
  } else if (!meshesVisible) {
    log('PARTIAL: App and camera working, but no visible meshes', 'error');
  } else {
    log('SUCCESS: 3D scene is rendering!', 'success');
    log(`Rendering ${meshInstances.length} mesh instances`, 'success');
  }

}, 3000);
</script>
</body>
</html>
